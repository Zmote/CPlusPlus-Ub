#ifndef SRC_BOUNDEDQUEUE_H_
#define SRC_BOUNDEDQUEUE_H_

#include <queue>
#include <stdexcept>
#include <mutex>
#include <condition_variable>
#include <algorithm>
#include <memory>
#include <chrono>

template<typename T,typename M = std::mutex,typename CV = std::condition_variable>
class BoundedQueue{
public:
	using value_type = T;
	using size_type = std::size_t;
	using reference = T &;
	using const_reference = T const &;
	using guard = std::lock_guard<M>;

	BoundedQueue(size_type const q_size)
	:queue_size_{q_size},elements_{0},head_{0},
	queue_{std::make_unique<char[]>(queue_size_*sizeof(T))}{
		if(queue_size_ <= 0) throw std::invalid_argument{"BoundedQueue can't be empty"};
	}

	BoundedQueue(BoundedQueue const & other_queue)
	:BoundedQueue{other_queue.queue_size_}{
		if(!other_queue.empty()){
			for(unsigned int i = 0; i < other_queue.size();i++){
				value_type const & elem_in_queue =
						*other_queue.get_element_pointer_at(((other_queue.head_ + i)%other_queue.capacity()));
				this->push(elem_in_queue);
			}
		}
	}

	BoundedQueue(BoundedQueue && other_queue){
		swap(other_queue);
	}

	~BoundedQueue(){
		while(!empty())
			this->clear();
	}

	BoundedQueue & operator=(BoundedQueue const & other_queue) noexcept{
		if(this != &other_queue){
			BoundedQueue temporaryBuffer{other_queue};
			swap(temporaryBuffer);
		}
		return *this;
	}

	BoundedQueue & operator=(BoundedQueue && other_queue)noexcept{
		if(this != &other_queue){
			swap(other_queue);
		}
		return *this;
	}

	bool empty() const noexcept{
		return elements_ == 0;
	}
	bool full() const noexcept{
		return elements_ == queue_size_;
	}
	size_type size() const noexcept{
		return elements_;
	}
	size_type capacity() const noexcept{
		return queue_size_;
	}

	value_type pop(){
		if(empty()) throw std::logic_error{"Can't pop from empty Queue"};
		value_type * value_to_pop = get_element_pointer_at(head_);
		value_type return_value{std::move(*value_to_pop)};
		value_to_pop->~T();
		head_ = (head_ + 1) % (capacity());
		elements_--;
		return return_value;
	}

	bool try_pop(reference elem){
		if(empty()){
			return false;
		}
		return true;
	}

	bool try_pop_for(reference elem, auto timespan){
		return false;
	}

	void push(const_reference elem){
		if(full()) throw std::logic_error{"Can't push on full Queue"};
		guard lock{this->lock_};
		new (get_element_pointer_at(tail())) value_type{elem};
		elements_++;
	}

	void push(value_type && elem){
		if(full()) throw std::logic_error{"Can't push on full Queue"};
		guard lock{this->lock_};
		new (get_element_pointer_at(tail())) value_type{std::move(elem)};
		elements_++;
	}

	bool try_push(value_type const & elem){
		if(full())
			return false;
		return true;
	}

	bool try_push(value_type && elem){
		if(full())
			return false;
		return true;
	}

	bool try_push_for(const_reference elem, auto timespan){
		return false;
	}

	bool try_push_for(value_type && elem, auto timespan){
		return false;
	}

	void swap(BoundedQueue & other_queue) noexcept{
		std::swap(queue_,other_queue.queue_);
		std::swap(elements_,other_queue.elements_);
		std::swap(queue_size_,other_queue.queue_size_);
		std::swap(head_,other_queue.head_);
	}

private:
	size_type queue_size_{};
	size_type elements_{};
	size_type head_{};
	std::unique_ptr<char[]> queue_;
	mutable M lock_;
	CV condition_variable_;

	void clear(){
		get_element_pointer_at(head_)->~T();
		head_ = (head_ + 1) % (capacity());
		elements_--;
	}

	value_type * get_element_pointer_at(size_type index) const noexcept{
		return reinterpret_cast<value_type*>(queue_.get()) + index;
	}

	size_type tail() const{
		return (head_ + elements_) % capacity();
	}
};


#endif /* SRC_BOUNDEDQUEUE_H_ */
